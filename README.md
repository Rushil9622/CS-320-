How can I ensure that my code, program, or software is functional and secure?
- Call me old-school, but I still think manual review is just as important as automated testing. Don’t get me wrong, testing with plug-ins like JUnit or NUnit is incredibly helpful, and for this project was a key factor in producing clean, readable, functional code. However, I feel that manually reviewing your code in detail is just as important (not more important, mind you, but as important). The two should be used together to create your application / program. I like to follow my logic in my initial draft of code to see just how flawed it is. I have a tendency to just sit and write when the stakes aren’t super high, a habit I picked up from drafting papers in various English classes growing up, and only exacerbated by my previous work as a public-speaker where talking “off the cuff” was the norm. However, I also have the piece of mind to know that my first draft of code is never going to be perfect. Manual review before writing my tests ensures that major flaws are removed initially, and testing for more minor bugs can commence afterwards.
How do I interpret user needs and incorporate them into a program?
- Since “user needs” are what drive the initial development of the application, it’s hard to ignore them at any point during the SDLC. One important thing to remember, of course, is that the user sometimes wants the world, and you as a developer know that you may only be able to deliver a continent or two, so meeting them in the middle is the challenge. The tools at your disposal may limit your ability to create something the client exactly wants, but creativity is rewarded when it results in other options to produce the same results. Being able to look past the “can’t do that”’s and turn them into “let’s try this”’s is an important skill that any developer should have.
How do I approach designing software?
- My mind works in a unique way in that I can see both the big picture and the fine details that make up said picture. Considering this, my approach to developing software typically starts with me pondering what I want the overall application to do in the end, then building one small piece at a time, adding on as I go. I don’t always think of how many objects I’ll need or what methods I’ll have to create in order to make something work; I just start coding. As I hit roadblocks, I work through them by trying all sorts of different solutions, and as my code get’s longer I pause development at various times to review it for places that can be shortened or refactored. I rely on those that came before me as well, so as not to reinvent the wheel. If a method or solution has been developed before, how can I incorporate it or modify it to fit my own needs? Taking menial tasks out of coding is helpful as well; using the right IDE with error checking greatly reduces the amount of time spent on little issues like syntax errors, while allowing me to focus on more important things like flow and scope.
